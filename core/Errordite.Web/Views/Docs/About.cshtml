@using Errordite.Web.Models.Docs
@using Errordite.Web.Extensions
@{
    ViewBag.Title = "About Errordite";
}

@section header
{
    @Html.Partial("Docs/Tabs", DocsTab.Api) 
}

<section class="centered" id="about">
    <div class="content help">
        <h2>About Errordite</h2>
        <p>We have spent years helping develop busy websites and seeing the large numbers of errors filling up the logs.  Some of these errors
            were caused by genuine bugs that slipped into production, while many others were the result of unexpected URLs from a searchbot or once-a-day database
            contention problems, caused by some heavy-duty SQL job running at 3am.  The variety of severity and frequency of these different types of errors
            combined with the flat, distributed and un-parseable nature of the error logs meant dealing with these errors in any proactive way was near-impossible.
        </p>
        <p>Errordite was developed as a solution to this problems, with 2 main goals in mind:
        </p>
        <ol>
            <li>to show you <strong>exactly what issues are being experienced</strong> by an application (that is to say the underlying problems resulting in errors)</li>
            <li>to help you to <strong>process these issues</strong> - assign them to someone to be investigated and fixed them or else choose to ignore them</li>
        </ol>
        
        @*<p>Errordite is different to other error logging applications in that we 
            <strong>allow you to redefine exactly which Errors belong to which Issues</strong>.
        </p>
        
        <p>Incoming Errors are allocated to an Issue in a sensible way, but if required you can adjust the rules that determine what
            Errors get attached to each Issue - <em>based on any attribute of your Errors</em>. We've
            also designed a <strong>intuitive visual way of seeing and definining these rules</strong>.  Check out the video
            on the home page for a demonstration.
        </p>*@
        
        <p>On the face of it, the natural way to categorise errors into issues is by their exception type and the method from which they were thrown,
            and indeed this is Errordite's default mode. But sometimes this doesn't work.  For example:</p>
        <ol>
            <li>multiple different errors result in the same exception type (because of overzealous exception wrapping or because the 
                precise error is explained in the exception message)
            </li>
            <li>conversely, a bunch of different exceptions all come from the same root cause, and you want to consider them the same
                issue
            </li>
        </ol>
        
        <p>To get around these scenarios, Errordite has an intuitive and powerful visual rule creation facility to allow you to redefine
            an issue so that it includes a more (or less) precise set of errors.  Check out the video on the home page to see how it works.
            <strong>You can use any attribute of incoming errors to make a rule - including custom data.</strong>
        </p>
        
        <h2>Features</h2>
        <p>As well as this, Errordite has:</p>
        <ul><li>a live updating dashboard, so you can see errors happening in real time</li>
            <li>alerts when a new issue occurs, or a solved issue recurs</li>
            <li>graphs to show you the historical number of occurrences of an issue per day plus their distribution over 24 hours </li>
            <li>quick Lucene-based search</li>
            <li>the ability to receive custom data with each error</li>
            <li>an overall activity log so you can see exactly who has done what to which issues</li>
            <li>integration with HipChat</li>
        </ul>
        
@*        <h2>Roadmap</h2>
        <p>This is just the start.</p>*@
        @*        <h2>Error logging - the limitations</h2>
        <p>
            Software development has come on a great deal in recent years. Agile methods have made it more likely that people 
            actually get the software they want. Automated testing has made it more likely that the software works properly 
            first time out. All manner of technologies have reduced the friction involved in development.  
        </p>
        <p>
           Regardless of all this all software will contain bugs and generate exceptions - and the ability to deal with these 
            exceptions is somewhat limited. For a typical web application, each exception will result in an entry in a log 
            entry locally, on the web server. This is fine, except: 
        </p>
        <ul>
            <li>if you have multiple servers, your logs will be spread across multiple locations
</li><li>you can't see how many different Issues you have; only a mass of Errors, which may be all the same underlying problem, or all different
</li><li>it's just text - it has no structure
</li><li>there is no application-level context around the errors. Who was logged in at the time? What URL were they accessing? etc.
</li><li>it's passive - you only find out that something's gone wrong if you carefully sift through the logs (or more likely when a user reports a bug) 
</li><li>there's no way of directly recording information against an error: even if someone solves the problem, if it recurs in the future you can't see the information previously learned about it 
        </li></ul>
        <p>So not fine at all then, really.  To summarise, it’s hard to know exactly what type of errors your application is 
            suffering from and similarly difficult to be sure you’ve fixed them. all errors for all applications sent to a single place.
        </p>
        <p>
With all this in mind, we developed Errordite to address all these problems. </p>
        <h2>How Errordite makes it better</h2>
        <p>Errordite:
        </p>
        <ul>
            <li>is a central place to manage all Errors from all your applications and servers
</li><li>groups all your Errors into Issues - you don't get swamped by repeated occurrences
</li><li>logically structures the Error information, including nested exceptions
</li><li>stores whatever contextual data you choose to send with each Error (e.g. HTTP context, current username, environment information)
</li><li>alerts you whenever a new Error occurs, or an Issue you thought was solved recurs
</li><li>allows you to record information against an Issue and assign it to different users for investigation
        </li></ul>
        <h2>What makes Errordite special?</h2>
        <p>
           Other services exist to receive your application's errors - so what's different about Errordite?
        </p>
        <ul>
            <li>live-updating dashboard showing you each Error and Issue occurring in your application</li>
            <li>you can decide what constitutes an Issue.  You can define flexible matching rules on the exception type, 
                exception message, some part of the call stack, the URL, a particular user, the user agent and much more </li>
        </ul>*@
       
    </div>
   
</section>